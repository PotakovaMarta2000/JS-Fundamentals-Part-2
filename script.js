//Условия
// Этот принцип помогает нам пустить программу или действие по правильному пути, в зависимости от обстоятельств

// if (условие) {
//     // блок кода, выполнится если условие выполняется
// } else {
//     // блок кода, выполнится в противном случае
// }

// Простейшее условие

if (2*4 == 8) {
    console.log('Верно!');
} else {
    console.log('Неверно!');
}

// Условие должно преобразовываться в логический тип данных: true, false
// Операторы сравнения
// >, <, >=, <=  больше, меньше, больше или равно, меньше или равно
// == не строгое сравнение
// === строгое сравнение
// != не строгое неравенство
// !==  строгое неравенство

//Способ №1
// Вложенные условия

let num = 50;

if (num <49) {
    console.log('Неверно!');
} else if (num >100) {
    console.log('Много!');
} else {
    console.log('Верно');
}

//Пример

let phrase = prompt('Скажи слово друг и заходи');

if (phrase === 'Друг') {
    alert('Привет');
} else {
    alert('Я тебя не знаю');
}

//Способ №2
//Тернарный оператор, в его работе участвуют 3 аргумента
// (num==50) ? console.log('Верно') : console.log('Неверно!');
//Бинарный оператор, в его работе участвуют 2 аргумента, пример 2+2
//Унарный оператор, в его работе участвуют 1 аргумент, например инкремент/декремент

//Способ №3
//Конструктор switch, это модификация поддерживающая сразу несколько if()

let numb = 50;

switch (numb) {
    case numb < 49:
        console.log('Неверно!');
        break;
    case numb > 100:
        console.log('Много!');
        break;
    case 50:
    console.log('Верно');
        break;
    default:
    console.log('Что то пошло не так!'); 
        break;      
}

//Пример
let lang = 'ru';

switch (lang) {
	case 'ru':
		alert('Русский текст');
    break;
	case 'en': 
		alert('Английский текст');
	break;
	case 'de': 
		alert('Немецкий текст');
	break;
	default:
		alert('Данный язык не поддерживается'); 
	break;
}

//Циклы
/* Все технические средства, все программы направлены на автоматизацию процессов и облегчению нашего труда
Так мы заменяем однотипные человеческие действия. Так и в программировании, вместо того чтобы писать множество
одинаковых действий, например покрасить много различных кнопок  в один цвет-мы заменяем это одним 
небольшим циклом, который сделает это за нас*/

/* Самый простой вид цикла while */ 

let number = 50;

while (number < 55) {
    console.log(number);
    number++;
}

/* Цикл do while Такой цикл нам необходим, когда мы хотим сначало что то сделать, 
а затем проверить это условие*/

let number = 50;
do {
    console.log(number);
    number++;
}
while (number <55);

/* Цикл for, в этом цикле мы можем максимально подробно написать все условия */

for (let i = 1; i < 8; i++) {
    if (i == 6) {
        // break /* цикл останавливается */
        continue /*прерывание 1ой итерации цикла, далее цикл продолжается */
    }
    console.log(i);
}

//Конструкция for 
//Конструкция for задает цикл: код, размещенный внутри нее, будет повторен заданное количество раз

//Выведем последовательность чисел от 0 до 10:

for (let i = 0; i <= 10; i++) {
	console.log(i);
}

//Выведем последовательность чисел от 10 до 0:

for (let i = 10; i >= 0; i--) {
	console.log(i);
}

//Выведем четные числа от 0 до 10:

for (let i = 2; i <= 10; i += 2) {
	console.log(i);
}

//Выведем элементы массива:

let arr = ['a', 'b', 'c', 'd', 'e'];

for (let i = 0; i < arr.length; i++) {
	console.log(arr[i]);
}

//Конструкция for-in
//Конструкция for-in создает цикл для перебора объекта

//Переберем ключи объекта и выведем их на экран:

let obj = {a: 1, b: 2, c: 3};

for (let key in obj) {
	console.log(key); // выведет 'a', 'b', 'c'
}

//А теперь выведем элементы объекта

let obj = {a: 1, b: 2, c: 3};

for (let key in obj) {
	console.log(obj[key]); // выведет 1, 2, 3
}


//Задачи

//5.Дан массив с элементами [1, 2, 3, 4, 5]. С помощью цикла for выведите все эти элементы на экран.

let arr = [1, 2, 3, 4, 5];

for(let i = 0; i< arr.length; i++){
    console.log(arr[i]);
}


//6.Дан массив с элементами [1, 2, 3, 4, 5].
//С помощью цикла for найдите сумму элементов этого массива. Запишите ее в переменную result.

let arr = [1, 2, 3, 4, 5];
let result = 0;
for(let i=0; i < arr.length; i++){
    result += arr[i];
}
document.write(result);

//7. Дан объект obj. С помощью цикла for-in выведите на экран ключи и элементы этого объекта.

let obj = {green: 'Зеленый', red:'Красный', black:'Черный'};

for(key in obj){
    console.log(key);
}

//8. Дан объект obj с ключами Коля, Вася, Петя с элементами '200', '300', '400'. 
//С помощью цикла for-in выведите на экран строки такого формата: 'Коля - зарплата 200 долларов.'

let obj = {'Nikola ': 200, 'Vasya ':300, 'Petya ': 400};

for(key in obj){
    document.write([key]+ ' - Зарплата '+ obj[key]+' долларов'+'<br>');
}

// 9. Дан массив с элементами 2, 5, 9, 15, 0, 4. С помощью цикла for и оператора if выведите на экран столбец 
//тех элементов массива, которые больше 3-х, но меньше 10.

let arr = [2, 5, 9, 15, 0, 4];
    for (let i = 0; i < arr.length; i++) {
        if (arr[i] > 3 && arr[i] < 10) {
            console.log(arr[i]);
        }
    }

//10. Дан массив с числами. Числа могут быть положительными и отрицательными. 
// Найдите сумму положительных элементов массива.

let arr = [-5, 4, -1, 8];
    let result = 0;

    for (let i = 0; i < arr.length; i++) {
        if(arr[i] > 0) {
        result += arr[i];
        console.log(result);
    }
}

//11. Дан массив с элементами 1, 2, 5, 9, 4, 13, 4, 10. С помощью цикла for и оператора if проверьте есть ли 
//в массиве элемент со значением, равным 4. Если есть - выведите на экран 'Есть!' и выйдите из цикла. 
//Если нет - ничего делать не надо.

let arr = [1, 2, 5, 9, 4, 13, 4, 10];
for (let i = 0; i < arr.length; i++) {
if (arr[i] == 4) {
alert('Есть!');
break;
}
}

//12. Дан массив числами, например: [10, 20, 30, 50, 235, 3000]. Выведите на экран только те числа из массива, 
//которые начинаются на цифру 1, 2 или 5.

let arr = ['10', '20', '30', '50', '235', '3000'];

for(i = 0; i < arr.length; i++){
    if(arr[i][0] == '1'|| arr[i][0] == '2' || arr[i][0] =='5'){
        console.log(arr[i]);
    }
}

//12.2 not work
// let arr = ['10', '20', '30', '50', '235', '3000'];

// for (let i = 0; i < arr.length; i++) {
//     if (arr[i].toString()[0] == '1' || arr.toString()[0] == '2' || arr.toString()[0] == '5') {
//         console.log(arr[i]);
//     }
// }

//13.  Дан массив с элементами 1, 2, 3, 4, 5, 6, 7, 8, 9. 
//С помощью цикла for создайте строку '-1-2-3-4-5-6-7-8-9-'.

let arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];

for (let i = 0; i < arr.length; i++) {
    document.write(arr.join('-')[i].toString(arr));
} //здесь нам помогает метод join (разделитель)- который ставит между элементами разделитель

//13.2 not work
// let arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];
// let def = '';
// for(i = 0; i < arr.length; i++){
// def += arr[i]+'-';
// }
// document.write('-'+def);

/* 14. Составьте массив дней недели. С помощью цикла for выведите все дни недели, а выходные дни выведите 
жирным. */

let days = ['Mn', 'Tu', 'We', 'Th', 'Fr', 'St', 'Sn'];

for (let i = 0; i< days.length; i++) {
    if (i == 5 || i ==6) {
        document.write( '<b>' + days[i] + '</b> <br>');
    } else {
        document.write(days[i] + '<br>');
    };
};

//15. Составьте массив дней недели. С помощью цикла for выведите все дни недели, а текущий день выведите курсивом.
//Текущий день должен храниться в переменной day.

let week = ['Mn', 'Tu', 'We', 'Th', 'Fr', 'St', 'Sn'];
let day = 6;
for (i = 0; i < week.length; i++) {
    if (week[i] == day) {
        document.write('<b>' + week[i] + '</b>');
    } else {
        document.write(week[i] + ' ');
    }
}

//16.  Дано число n=1000. Делите его на 2 столько раз, пока результат деления не станет меньше 50. 
//Какое число получится? Посчитайте количество итераций, необходимых для этого (итерация - это проход цикла), 
//и запишите его в переменную num.

let n = 1000;
let num = 0;
while (n > 50) {
    num++;
    n /= 2;
}
console.log(n);
console.log(num);

//Функции
// Функции- это наши действия в скрипте, они используют различные типы данных 
// и изменяют информацию так как мы им укажем, так же это значительно уменьшает нам код-прямо как циклы
//Имя функции.Существует внегласное правило, что оно должно быть глаголом с припиской того, над чем вып-ся 
//действие пример - showForm, getName
//Бывают анонимные функции, кот вып-ся "здесь и сейчас". Без имени мы не можем к ним обращаться

// Объявление функции
    function showFirstMessage(text) {
        alert(text); 
    }
    showFirstMessage('Hello World!');
        

// Function Declaration Функция кот объявлена в потоке кода.Такие функции, как и var сщздается до начала кода
//то есть можем вызывать их еще до объявления

// Локальная переменная
function showFirstMessage(text) {
    alert(text); 
    let num = 20; 
    }
    showFirstMessage('Hello World!');
    console.log(num);// Получим ошибку, мы обьявили переменную внутри функции,
    //а значит снаружи она видна не будет

//Глобальная переменная
let num = 20;

function showFirstMessage(text) {
    alert(text); 
    num = 10; 
    }
showFirstMessage('Hello World!');
console.log(num);

// Глобальная переменная + Локальная переменная, объявлены 2 разные переменные внутри 1ой функции
// Замыкание функции
/* Замыкание функции-когда внутри нее есть обращение к какой либо переменной,
    функция сначала ищет эту переменную внутри себя, а потом уже во внешних переменных.
    Поэтому замыкание-это функция вместе со всеми переменными которые ей доступны*/
    let num = 20; //Глобальная переменная

    function showFirstMessage(text) {
    alert(text); 
    let num = 10; // Локальная переменная
    console.log(num);
    }
    showFirstMessage('Hello World!');
    console.log(num);

//Кроме всех этих действий, функция может также вернуть какое то значение, при помощи ключевого слова return
//при том же как только функция видит return, она прекращает свое действие

function calc(a,b) {
    return (a+b);
}
console.log(calc(3,4));
console.log(calc(8,4));

//Как мы уже знаем, что если внутри функции мы объявим переменную, то во внешнем мире она видна не будет
//Но при помощи return,мы можем записать переменную вне функции
function retVar() {
    let num = 50;
    return num;
}

let anotherNum = retVar();
console.log(anotherNum);

//Function Expression Когда мы функцию присваиваем в переменную
//Эта функция создается только тогда, когда код до нее доходит.Мы не можем вызвать ее заранее, 
//как мы это делали при Function Declaration

let calc = function(a,b) {
    return (a+b);
}
console.log(calc(3,4));
console.log(calc(8,4));

// ES6 Стрелочная функция

let calc = (a,b) => a+b;

console.log(calc(3,4));
console.log(calc(8,4));

//Методы и свойства у строк и чисел.
//Методы-вспомогательные функции, а свойства-вспомогательные значения.

// Методы и свойства у строк 
let str = 'test';
console.log(str.length);// свойствo

console.log(str.toUpperCase()); //Метод
console.log(str.toLowerCase()); //Метод

// Методы и свойства у Number

let twelve = '12.2';
let twelve = '12.2px';
console.log(Math.round(twelve));
console.log(parseInt(twelve));
console.log(parseFloat(twelve));

//Callback-функции

function first() {
    //что-то делаем, спец структура, кот делает задержку на полсекунды
    setTimeout(function() {
        console.log(1);
    }, 500);
}

function second() {
    console.log(2);
}
first();
second();

//Callback-функции-это функция кот должна быть выполнена только после того,как др функция завершила свое вып-е
//т.е.если мы хотим, чтобы 2я функция вып-сь только после 1ой-то мы ее должны задать как Callback-функцию
//в кач-ве аргумента, любая функция может взять др функцию и она уже будет называться Callback functions

function learnJS(lang, callback) {
    console.log('Я учу' + lang);
    callback();
}
learnJS('JavaScript', function() {
    console.log('Я прошел несколько уроков по основам!');
})

//Callback-функцию можно создать и вне вызова функции и просто передавать туда готовые результаты

function learnJS(lang, callback) {
    console.log('Я учу' + lang);
    callback();
    }

    function done() {
        console.log('Я прошел несколько уроков по основам!');
    }
    learnJS('JavaScript', done);
    
    // В общем Callbackи позволяют нам быть уверенными в том, что опред код не начнет исполнение до того
    // момента, пока др код не завершит свое исполнение